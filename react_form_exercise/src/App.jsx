import { useState } from "react";
import { v4 as uuidv4 } from "uuid";

import "./App.css";

function App() {
  // Create an array with tasks that contains an object for each task. This is the initial state that is passed down to <List />. This is the state.
  const [tasks, setTasks] = useState([
    {
      task: "First task",
      completed: false,
      id: 1,
    },
  ]);

  // Since App is the one that owns the state we create a function that adds a new task and gives it a unique id
  // Each task is created like an object with these properties. taskName comes from
  function addTask(taskName) {
    // Recieves the taskName from the input field
    console.log(taskName);
    const newTask = {
      task: taskName,
      completed: false,
      id: uuidv4(),
    };
    console.log(newTask);
    // Adds it to state which takes the old state (oldTasks) and return the new state (newTasks) and concat it with the old state.
    setTasks((oldTasks) => oldTasks.concat(newTask));
  }

  // Here we update the state. We take the oldState where we have filtered out the task that is NOT equal to whatever id that we receive from the function.
  function completeTask(id) {
    setTasks((oldState) => oldState.filter((task) => task.id !== id));
  }

  return (
    <div className="App">
      {/* Add task gets a function that calls the function addTask */}
      <Form addTask={addTask} />
      {/* List gets the initial state from the const [tasks, setTasks]*/}
      {/* List also retrieves a function called completeTask which points to the actual function completeTask*/}
      <List tasks={tasks} completeTask={completeTask} />
    </div>
  );
}

// Form recieves props so we can send down addTask to the component
function Form(props) {
  // This function pick ups the data and we send that up to whoever has the addTask. Which is in App.
  function submit(e) {
    e.preventDefault();
    console.log(e.target.elements.task.value);
    // We add the props in front of the addTask function because the function comes from inside App
    props.addTask(e.target.elements.task.value);
    // completed: false, generated by App
    // task: form
    // id: generated by App
  }
  return (
    // We use Submit because form validation will only run with Submit and not Click
    // We use a local function called submit
    <form onSubmit={submit}>
      <input required type="text" name="task" id="form_task"></input>
      <button>Add Task</button>
    </form>
  );
}

// For list to pick up the state tasks we pass in props
function List(props) {
  return (
    // We use map to map through the tasks array and create a ListItem for each of the tasks with their respective properties
    <ul>
      <p>Some List</p>
      {props.tasks.map((task) => (
        // To show each task in as their own element we use the ... spread operator to devide the array into meaningfull tasks
        // completeTasks is passed down to ListItem coming from the parent component List. We use props because it's passed down from it's parent component.
        <ListItem completeTask={props.completeTask} {...task} />
      ))}
    </ul>
  );
}

// ListItem is passed in props since we have used the spread operator ...task in on the <ListItem /> in the <List /> component
function ListItem(props) {
  return (
    <li>
      <article>
        {/* Using the {props.task} then gets each individual task from the ListItem because we used the spread operator ...task on the ListItem.   */}
        <p>{props.task}</p>
        {/* We use an anonomys function in the onClick event to not call it immidiatly after it's clicked. We parse in props.id to send the id back to the parent component so the correct task is removed */}
        <button onClick={() => props.completeTask(props.id)}> Complete</button>
      </article>
    </li>
  );
}

export default App;
